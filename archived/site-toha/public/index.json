[{"categories":["Portfolio"],"contents":" Role: Lead Gameplay Engineer | Engine: Unreal Engine 5.7 | Platforms: PC, PS5, Xbox Series X\nHuli: Nine Tails of Vengeance is a combat-driven Action RPG featuring deep melee combat, AI-coordinated enemy encounters, and a modular plugin architecture built for scalability. This page walks through the core technical systems I designed and implemented.\nArchitecture Overview The project is built on a three-tier modular plugin architecture that enforces clean dependency boundaries and supports independent iteration across teams.\n┌─────────────────────────────────────────────────────────────────┐ │ TIER 3 — GameFeature Plugins │ │ (Content-specific logic, can depend on all tiers) │ │ │ │ Game modes, level-specific encounters, quest logic │ └──────────────────────────────┬──────────────────────────────────┘ │ depends on ┌──────────────────────────────▼──────────────────────────────────┐ │ TIER 2 — MainGame Module │ │ (Core gameplay: characters, controllers, inventory) │ │ │ │ Source/S2/ — Foundation, Character, Combat, AI, Items, UI │ └──────────────────────────────┬──────────────────────────────────┘ │ depends on ┌──────────────────────────────▼──────────────────────────────────┐ │ TIER 1 — Generic Plugins │ │ (Reusable systems, zero game-specific dependencies) │ │ │ │ GAS, Hitbox, ComboGraph, AI Framework, Team, Audio, Save │ └─────────────────────────────────────────────────────────────────┘ Key constraint: Generic plugins (Tier 1) cannot depend on MainGame or GameFeature modules. This forces clean API boundaries and makes plugins portable across projects.\nPlugin Catalog (19+ Custom Plugins) Domain Plugin Purpose Combat SipherComboGraph Visual node-based combo editor with undo/redo and runtime ability integration Combat SipherHitbox Animation notify-driven hit detection with predicted traces for low-FPS robustness Combat SipherAttributes GAS attribute set foundation (7 specialized sets) AI SipherAIScalableFramework Hybrid State Tree + BT framework with coordinator system AI SipherAIBPTools Blueprint authoring tools for AI designers Audio SipherAudio Runtime audio framework with editor test harness Narrative SipherSubtitle Customizable subtitle rendering system Cinematic SipherCutsceneCore / Manager / Tools Three-module cinematic pipeline Persistence SipherSaveLoadManager Save/load with checkpoint integration Gameplay SipherTimeDilationManager Frame-accurate time manipulation for slow-mo and hit stops Team SipherTeam Faction affiliation and relationship queries Framework SipherCore Shared types, utilities, and base classes Framework SipherInteractionObjectFramework Smart Object-based interaction system Framework SipherFABRIK Full-body IK solution Framework SipherInputReplay Input recording and deterministic playback Framework SipherMontageStandards Animation montage naming and section conventions Tools SipherEnemyTools Content validation for enemy assets Combat Systems The combat pipeline is the project\u0026rsquo;s centerpiece — a deeply integrated stack of GAS, hitbox detection, combo graphs, and a universal damage pipeline that delivers frame-precise, direction-aware melee combat.\nGameplay Ability System (GAS) Integration We extend Unreal\u0026rsquo;s GAS with a custom Ability System Component that supports runtime data passing through an Ability Data Queue pattern. This allows abilities to receive context-specific parameters without subclassing per-variant:\n// Runtime data passed alongside ability activation struct FSipherAbilitySpecQueueItem { FGameplayAbilitySpecHandle SpecHandle; // Generic data container — abilities introspect this at activation TInstancedStruct\u0026lt;FSipherGenericAbilityData\u0026gt; GenericAbilityData; }; // Activation with data: bool USipherAbilitySystemComponent::TryActivateAbilityWithData( FGameplayAbilitySpecHandle Handle, TInstancedStruct\u0026lt;FSipherGenericAbilityData\u0026gt;\u0026amp;\u0026amp; Data) { AbilityDataQueue.Enqueue({ Handle, MoveTemp(Data) }); return TryActivateAbility(Handle); } Why this matters: Traditional GAS requires creating ability subclasses for each parameter variation (e.g., light attack vs. heavy attack vs. aerial attack). The data queue pattern lets a single ability class handle all variants by reading runtime context from the queue during activation — dramatically reducing class proliferation.\nAttribute Architecture (7 Specialized Sets) Attribute Set Domain Key Attributes Offensive Attack AttackPower, CriticalChance, CriticalMultiplier, FinisherDamage Defensive Defense DefenseRating, DamageNegation, Vulnerability PlayerCombat Resources Stamina, FocusPoints, MagicPool ElementalResistance Elements Fire, Ice, Thunder, Earth, Poison resistance CharacterMovement Mobility MoveSpeed, DodgeDistance, AgilityStat Consumable Items Consumable charges and cooldowns Shield Guard ShieldHealth, BlockReduction Universal Damage Pipeline All damage flows through a 7-stage execution pipeline — modular passes that can be independently modified, debugged, and extended:\nAttacker activates ability │ ▼ ┌─────────────────────┐ │ 1. SourceOutputDamage│ Attacker\u0026#39;s base damage + crit calculation └──────────┬──────────┘ ▼ ┌─────────────────────┐ │ 2. TargetDefense │ Defender\u0026#39;s armor negation + vulnerability └──────────┬──────────┘ ▼ ┌─────────────────────┐ │ 3. Immunity │ Resistance and full immunity checks └──────────┬──────────┘ ▼ ┌─────────────────────┐ │ 4. Elemental │ Elemental damage type processing └──────────┬──────────┘ ▼ ┌─────────────────────┐ │ 5. ShieldConsumption│ Shield break mechanics and overflow └──────────┬──────────┘ ▼ ┌─────────────────────┐ │ 6. SetAbsoluteDamage│ Override hooks for special scenarios └──────────┬──────────┘ ▼ ┌─────────────────────┐ │ 7. FinalApplication │ Apply to Health attribute + broadcast └─────────────────────┘ Each stage is a separate Gameplay Effect Execution Calculation — a design that makes it trivial to add new damage modifiers (e.g., \u0026ldquo;elemental weakness bonus\u0026rdquo;) without touching existing pipeline stages.\nDirection-Aware Parry System The parry system uses a state machine with directional attack classification — incoming attacks are analyzed by vector math to determine their offensive direction, enabling direction-specific block and parry animations:\n// Parry state machine enum class EParryState : uint8 { None, // No parry active Anticipation, // Wind-up frames (can cancel) Parrying, // Active parry window (perfect timing) Blocking, // Extended block window (reduced damage) Recovery, // End-lag (vulnerable) Success // Parry landed → counter-attack window }; // Attack direction classification for parry response enum class EDamageOffensiveDirection : uint8 { Vertical, // Overhead strikes Horizontal, // Sweeping attacks DiagonalLeft, // Upper-left to lower-right DiagonalRight, // Upper-right to lower-left Center // Stab / thrust }; The parry system feeds directly into the riposte chain — a successful parry opens a window for a direction-matched counter-attack sequence, creating risk/reward depth comparable to Sekiro-style deflection.\nVisual Combo Graph Editor Combat designers author attack chains in a node-based visual editor with full undo/redo support. The graph compiles to runtime state machines that integrate with GAS:\nNode Types:\nInput Nodes — Listen for player input during combo windows Condition Nodes — Gate transitions on stamina, cooldowns, or tags Execution Nodes — Trigger montages and gameplay effects Ability Nodes — Activate GAS abilities via the data queue pattern Action Pass Types:\nActivateAbility — GAS ability activation with runtime data PlayMontage — Animation playback with section targeting PhysicalAttack / SpellAttack — Melee or ranged damage dispatch CostStat — Stamina/resource deduction Hitbox System Hitboxes are driven entirely by Animation Notify States — animators place notify windows on montages, and the runtime traces weapon socket positions between frames:\nKey features:\nPredicted traces for 25-40 FPS robustness (interpolates missed positions) Per-hit deduplication via target cache to prevent double-damage Hit stop with configurable stacking (multiple hits don\u0026rsquo;t compound pause duration beyond a cap) Debug visualization via console variables for rapid iteration // Hit stop configuration — shipped values after extensive playtesting struct FHitStopConfig { float Duration = 0.1f; // Base pause duration float MinPlayRate = 0.03f; // Near-zero but not frozen bool bCosmetic = true; // Affects animation only, not gameplay float StackDecay = 0.5f; // Each stacked hit adds 50% less }; AI Framework The AI system is a hybrid architecture combining Unreal\u0026rsquo;s State Trees for high-level decision-making with Behavior Trees for tactical execution, coordinated through a centralized Coordinator that manages group behavior, formations, and resource budgeting.\nArchitecture ┌─────────────────────────────────────────────┐ │ AI Coordinator (Global) │ │ Budget management, threat prioritization │ │ Formation assignment, group commands │ └──────────┬──────────────┬───────────────────┘ │ │ ┌──────▼──────┐ ┌────▼────────────┐ │ State Tree │ │ State Tree │ │ (Macro AI) │ │ (Macro AI) │ ... per AI entity │ Patrol → │ │ Guard → │ │ Alert → │ │ Investigate → │ │ Combat │ │ Combat │ └──────┬──────┘ └────┬────────────┘ │ │ ┌──────▼──────┐ ┌────▼────────────┐ │ Behavior │ │ Behavior │ │ Tree │ │ Tree │ ... tactical execution │ (Tactics) │ │ (Tactics) │ └─────────────┘ └─────────────────┘ Coordinator System The Coordinator prevents the classic \u0026ldquo;one-at-a-time\u0026rdquo; problem in action games where enemies politely wait their turn. Instead:\nAttack budgets limit simultaneous attackers (e.g., max 3 of 8 enemies can swing at once) Formation slots position enemies in rings/arcs with priority-based assignment Group commands synchronize behavior (coordinated retreats, flanking maneuvers, staggered attacks) Threat alerting propagates player detection across nearby groups Scalable Difficulty Parameters Each AI entity has a SipherAIScalableParametersComponent that multiplies core attributes:\nParameter Effect Range DamageMultiplier Outgoing damage scaling 0.5x – 2.0x HealthMultiplier Health pool scaling 0.5x – 3.0x ReactionTimeMultiplier Decision delay 0.5x – 2.0x AggressionLevel Attack frequency Low / Medium / High These are tuned per-difficulty and per-encounter, allowing designers to create dynamic difficulty curves without touching behavior logic.\nPerformance: 50+ AI at 60 FPS Achieving 50+ concurrent AI entities at locked 60 FPS required three key optimizations:\nAI LOD System — Entities beyond camera range or at distance run simplified behavior (fewer perception queries, reduced decision frequency) Time Slicing — Group coordination decisions are batched across frames rather than evaluated every tick Smart Object Pooling — Interaction points are pre-allocated and recycled instead of spawned dynamically Character System Hierarchy ASipherBasicCharacter ├── Implements 9 interfaces: │ ├── IAbilitySystemInterface │ ├── IGameplayTagAssetInterface │ ├── ILifeStateInterface │ ├── ICharacterCombatInterface │ ├── ISipherDomainSystemInterface │ ├── ICompanionControlInterface │ ├── ISipherSaveableInterface │ ├── ISipherCutsceneActorInterface │ └── IComboCharacterInterface │ ├── ASipherPlayerCharacter │ └── 60+ gameplay features (movement, combat, abilities, UI) │ └── ASipherAICharacter ├── ASipherAINonPlayerCharacter (friendly NPCs) └── ASipherMobCharacterBase (enemies) Component Architecture Characters are composed of specialized components rather than monolithic classes:\nComponent Responsibility SipherCharacterMovementComponent Enhanced movement with animation-aware turning SipherCharacterLifeStateComponent Death handling, respawn triggers, invincibility frames SipherCharacterStatComponent Runtime attribute tracking and UI binding SipherHitReaction Damage impact reactions (light/heavy/knockdown/stagger) SipherComboManagerComponent Combo graph execution and state tracking SipherCombatExecutionComponent Attack mechanics and damage dispatch SipherDismembermentComponent Gore/dismemberment on killing blows SipherShieldComponentBase Guard meter and block reduction SipherDamageFeedbackComponent VFX/SFX resolution for hit effects Design rationale: This composition-over-inheritance approach means each system can be developed, tested, and iterated independently. Adding dismemberment to a new enemy type is as simple as attaching the component — no subclassing required.\nAnimation Integration Combat feel is driven by 100+ Animation Notify States that synchronize gameplay mechanics to exact animation frames:\nNotify Categories Category Examples Purpose Hitbox ANS_SocketTracker Record weapon socket positions for trace-based hit detection Parry ANS_ParryWarp, ANS_ParryEnduranceWarp Root motion warping during parry animations Combo ANS_PerfectComboWindow, ANS_CounterWindow Frame-precise input windows for combo transitions Riposte ANS_RiposteChain Counter-attack warp after successful parry Cinematic AN_StartCinematicQTE QTE trigger points during finisher sequences Stance ANS_StanceWarp Smooth stance transitions with motion warping This animation-centric approach means combat designers control timing, not programmers. A parry window\u0026rsquo;s duration is set by the length of the notify state on the montage — designers adjust feel in the animation editor, not in code.\nPerformance Engineering Async Asset Loading All soft object references (montages, textures, VFX) are loaded asynchronously to prevent game-thread hitches:\n// BeginPlay — start async load void UMyComponent::BeginPlay() { Super::BeginPlay(); FStreamableManager\u0026amp; Mgr = UAssetManager::Get().GetStreamableManager(); StreamHandle = Mgr.RequestAsyncLoad( MontageRef.ToSoftObjectPath(), FStreamableDelegate::CreateUObject(this, \u0026amp;ThisClass::OnMontageLoaded) ); } // EndPlay — release handle to prevent leaks void UMyComponent::EndPlay(const EEndPlayReason::Type Reason) { if (StreamHandle.IsValid()) { StreamHandle-\u0026gt;ReleaseHandle(); } Super::EndPlay(Reason); } // Usage — safe access (nullptr if not yet loaded) UAnimMontage* Montage = MontageRef.Get(); Rule enforced project-wide: LoadSynchronous() is banned. Every asset load goes through RequestAsyncLoad() with proper handle cleanup.\nDelegate Pattern Components expose events through a private delegate + public getter pattern to prevent accidental reassignment:\n// Private delegate — cannot be directly assigned from outside DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnDamageReceived, float, Amount); UCLASS() class USipherHealthComponent : public UActorComponent { GENERATED_BODY() public: // Public getter returns reference — callers can bind, but not replace FOnDamageReceived\u0026amp; GetOnDamageReceived() { return OnDamageReceived; } private: FOnDamageReceived OnDamageReceived; }; Gameplay Tags — Compile-Time Safety All gameplay tags are declared natively for compile-time validation. RequestGameplayTag() is banned project-wide:\n// Header — compile-time tag declaration UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Combat_State_Parrying); UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Combat_Damage_Physical); UE_DECLARE_GAMEPLAY_TAG_EXTERN(TAG_Combat_Immunity_Stagger); // Source — tag definition UE_DEFINE_GAMEPLAY_TAG(TAG_Combat_State_Parrying, \u0026#34;Combat.State.Parrying\u0026#34;); UE_DEFINE_GAMEPLAY_TAG(TAG_Combat_Damage_Physical, \u0026#34;Combat.Damage.Physical\u0026#34;); UE_DEFINE_GAMEPLAY_TAG(TAG_Combat_Immunity_Stagger, \u0026#34;Combat.Immunity.Stagger\u0026#34;); Over 100 native tags organized by domain — combat, damage types, elements, force effects, AI states, and ability lifecycle.\nKey Technical Achievements 19+ Custom Plugins Modular architecture with enforced three-tier dependency boundaries. Each plugin is independently buildable and testable.\n7-Stage Damage Pipeline Execution-based damage processing with injectable stages for immunity, elemental, shield, and custom passes.\n50+ AI at 60 FPS Hybrid State Tree + BT with coordinator-managed formations, attack budgets, and LOD-based complexity scaling.\n100+ Animation Notifies Frame-precise combat mechanics authored by designers in the animation editor, not in code.\nTechnologies \u0026amp; Tools Category Technologies Engine Unreal Engine 5.7 (custom modifications) Languages C++ (primary), Blueprints (designer-facing systems) Core Systems Gameplay Ability System, State Trees, Behavior Trees, Smart Objects Rendering DLSS, Streamline, NIS (NVIDIA integrations) Animation Motion Warping, FABRIK IK, Kawaii Physics Version Control Perforce Platforms PC (Win64), PlayStation 5, Xbox Series X This showcase covers architectural decisions and system design patterns. Specific implementation details are under NDA.\nBuilt with Unreal Engine 5.7 — C++ throughout.\n","date":"January 15, 2026","hero":"/images/default-hero.jpg","permalink":"http://localhost:1313/posts/huli-technical-showcase/","summary":"\u003cdiv style=\"background:#1a1a2e; color:#e0e0e0; padding:1.5em 2em; border-radius:8px; margin-bottom:2em;\"\u003e\n\u003cp\u003e\u003cstrong\u003eRole:\u003c/strong\u003e Lead Gameplay Engineer  |  \u003cstrong\u003eEngine:\u003c/strong\u003e Unreal Engine 5.7  |  \u003cstrong\u003ePlatforms:\u003c/strong\u003e PC, PS5, Xbox Series X\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHuli: Nine Tails of Vengeance\u003c/strong\u003e is a combat-driven Action RPG featuring deep melee combat, AI-coordinated enemy encounters, and a modular plugin architecture built for scalability. This page walks through the core technical systems I designed and implemented.\u003c/p\u003e\n\u003c/div\u003e\n\u003chr\u003e\n\u003ch2 id=\"architecture-overview\"\u003eArchitecture Overview\u003c/h2\u003e\n\u003cp\u003eThe project is built on a \u003cstrong\u003ethree-tier modular plugin architecture\u003c/strong\u003e that enforces clean dependency boundaries and supports independent iteration across teams.\u003c/p\u003e","tags":["UE5","C++","GAS","AI","Combat","Architecture"],"title":"Huli: Nine Tails of Vengeance — Technical Deep Dive"},{"categories":["Tutorial"],"contents":"After years of working with Unreal Engine, I\u0026rsquo;ve compiled a list of best practices that have significantly improved code quality and team productivity.\n1. Use Forward Declarations Aggressively Minimize header dependencies by forward-declaring classes instead of including headers:\n// Bad - creates dependency chain #include \u0026#34;Character/LQPlayerCharacter.h\u0026#34; #include \u0026#34;Abilities/LQGameplayAbility.h\u0026#34; // Good - minimal dependencies class ALQPlayerCharacter; class ULQGameplayAbility; This reduces compile times and prevents circular dependencies.\n2. Prefer Interfaces for Cross-System Communication Instead of casting to concrete types, define interfaces:\nUINTERFACE(MinimalAPI, Blueprintable) class ULQDamageable : public UInterface { GENERATED_BODY() }; class LQTL_API ILQDamageable { GENERATED_BODY() public: virtual void ApplyDamage(float Amount, AActor* Instigator) = 0; virtual float GetCurrentHealth() const = 0; }; 3. Use Gameplay Tags Instead of Enums Gameplay Tags are more flexible and designer-friendly:\n// Runtime check: if (AbilityTags.HasTag(FGameplayTag::RequestGameplayTag(\u0026#34;Ability.State.Ready\u0026#34;))) { // Ability is ready } Conclusion These practices have helped me build more maintainable codebases. The key is consistency!\n","date":"December 15, 2025","hero":"/images/default-hero.jpg","permalink":"http://localhost:1313/posts/ue5-cpp-best-practices/","summary":"\u003cp\u003eAfter years of working with Unreal Engine, I\u0026rsquo;ve compiled a list of best practices that have significantly improved code quality and team productivity.\u003c/p\u003e\n\u003ch2 id=\"1-use-forward-declarations-aggressively\"\u003e1. Use Forward Declarations Aggressively\u003c/h2\u003e\n\u003cp\u003eMinimize header dependencies by forward-declaring classes instead of including headers:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Bad - creates dependency chain\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026#34;Character/LQPlayerCharacter.h\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e#include\u003c/span\u003e \u003cspan style=\"color:#75715e\"\u003e\u0026#34;Abilities/LQGameplayAbility.h\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// Good - minimal dependencies\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eALQPlayerCharacter\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eULQGameplayAbility\u003c/span\u003e;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eThis reduces compile times and prevents circular dependencies.\u003c/p\u003e\n\u003ch2 id=\"2-prefer-interfaces-for-cross-system-communication\"\u003e2. Prefer Interfaces for Cross-System Communication\u003c/h2\u003e\n\u003cp\u003eInstead of casting to concrete types, define interfaces:\u003c/p\u003e","tags":["UE5","C++","Best Practices"],"title":"UE5 C++ Best Practices for Gameplay Programming"},{"categories":["Mobile Games"],"contents":" Overview Register Race is a 3D casual mobile game where players take on the role of a cashier racing against AI opponents. The game combines fast-paced racing mechanics with a fun cashier register mini-game — type the correct price to speed ahead of the competition.\nPlatform: iOS / Android Engine: Unity Language: C# Genre: Hyper-casual / Racing\nView on App Store Key Features Cashier racing mechanic — type prices correctly to accelerate 3D environments with multiple themed tracks AI opponents with difficulty scaling Leaderboard and competitive ranking system ","date":"August 1, 2021","hero":"/images/projects/port_registerace_01.png","permalink":"http://localhost:1313/posts/mobile-register-race/","summary":"\u003cdiv style=\"display:flex; gap:1em; flex-wrap:wrap; align-items:flex-start; margin-bottom:2em;\"\u003e\n\u003cdiv style=\"flex:1; min-width:250px;\"\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eRegister Race\u003c/strong\u003e is a 3D casual mobile game where players take on the role of a cashier racing against AI opponents. The game combines fast-paced racing mechanics with a fun cashier register mini-game — type the correct price to speed ahead of the competition.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePlatform:\u003c/strong\u003e iOS / Android\n\u003cstrong\u003eEngine:\u003c/strong\u003e Unity\n\u003cstrong\u003eLanguage:\u003c/strong\u003e C#\n\u003cstrong\u003eGenre:\u003c/strong\u003e Hyper-casual / Racing\u003c/p\u003e\n\u003ca href=\"https://apps.apple.com/app/id1576795443\" target=\"_blank\" rel=\"noopener\"\u003e\n  View on App Store\n\u003c/a\u003e\n\u003c/div\u003e\n\u003cdiv style=\"flex:1; min-width:250px; max-width:400px;\"\u003e\n\u003cp\u003e\u003cimg src=\"/images/projects/port_registerace_02.png\" alt=\"Register Race Gameplay\"\u003e\u003c/p\u003e","tags":["Unity","C#","Mobile","Hyper-casual"],"title":"Register Race"},{"categories":["Mobile Games"],"contents":" Overview Assorted Detective is a 2D hidden-object puzzle game that will challenge your brain. Players must find the requested items across increasingly complex and cluttered scenes.\nPlatform: iOS / Android Engine: Unity Language: C# Genre: Puzzle / Hidden Object\nView on App Store Key Features Hidden object gameplay with hundreds of items to find Increasingly complex scenes with layered difficulty Timed challenges for competitive players Hint system for when you\u0026rsquo;re truly stuck ","date":"June 1, 2021","hero":"/images/projects/port_detective_01.png","permalink":"http://localhost:1313/posts/mobile-assorted-detective/","summary":"\u003cdiv style=\"display:flex; gap:1em; flex-wrap:wrap; align-items:flex-start; margin-bottom:2em;\"\u003e\n\u003cdiv style=\"flex:1; min-width:250px;\"\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eAssorted Detective\u003c/strong\u003e is a 2D hidden-object puzzle game that will challenge your brain. Players must find the requested items across increasingly complex and cluttered scenes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePlatform:\u003c/strong\u003e iOS / Android\n\u003cstrong\u003eEngine:\u003c/strong\u003e Unity\n\u003cstrong\u003eLanguage:\u003c/strong\u003e C#\n\u003cstrong\u003eGenre:\u003c/strong\u003e Puzzle / Hidden Object\u003c/p\u003e\n\u003ca href=\"https://apps.apple.com/app/id1562783371\" target=\"_blank\" rel=\"noopener\"\u003e\n  View on App Store\n\u003c/a\u003e\n\u003c/div\u003e\n\u003cdiv style=\"flex:1; min-width:250px; max-width:400px;\"\u003e\n\u003cp\u003e\u003cimg src=\"/images/projects/port_detective_02.png\" alt=\"Assorted Detective Gameplay\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003ch2 id=\"key-features\"\u003eKey Features\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eHidden object gameplay\u003c/strong\u003e with hundreds of items to find\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eIncreasingly complex scenes\u003c/strong\u003e with layered difficulty\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTimed challenges\u003c/strong\u003e for competitive players\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHint system\u003c/strong\u003e for when you\u0026rsquo;re truly stuck\u003c/li\u003e\n\u003c/ul\u003e","tags":["Unity","C#","Mobile","Puzzle"],"title":"Assorted Detective"},{"categories":["Mobile Games"],"contents":" Overview 2048 Park is a collection of 2048 puzzle game variants, offering multiple game modes and fresh takes on the classic 2048 formula. Players slide numbered tiles to combine them and reach higher values.\nPlatform: iOS / Android Engine: Unity Language: C# Genre: Puzzle / Casual\nView on App Store Key Features Multiple 2048 variants in a single app Progression system unlocking new game modes Clean UI with smooth tile animations Score tracking and personal bests ","date":"May 1, 2021","hero":"/images/projects/port_2048_01.png","permalink":"http://localhost:1313/posts/mobile-2048-park/","summary":"\u003cdiv style=\"display:flex; gap:1em; flex-wrap:wrap; align-items:flex-start; margin-bottom:2em;\"\u003e\n\u003cdiv style=\"flex:1; min-width:250px;\"\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e2048 Park\u003c/strong\u003e is a collection of 2048 puzzle game variants, offering multiple game modes and fresh takes on the classic 2048 formula. Players slide numbered tiles to combine them and reach higher values.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePlatform:\u003c/strong\u003e iOS / Android\n\u003cstrong\u003eEngine:\u003c/strong\u003e Unity\n\u003cstrong\u003eLanguage:\u003c/strong\u003e C#\n\u003cstrong\u003eGenre:\u003c/strong\u003e Puzzle / Casual\u003c/p\u003e\n\u003ca href=\"https://apps.apple.com/us/app/2048-park/id1557416639\" target=\"_blank\" rel=\"noopener\"\u003e\n  View on App Store\n\u003c/a\u003e\n\u003c/div\u003e\n\u003cdiv style=\"flex:1; min-width:250px; max-width:400px;\"\u003e\n\u003cp\u003e\u003cimg src=\"/images/projects/port_2048_02.jpg\" alt=\"2048 Park Gameplay\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003ch2 id=\"key-features\"\u003eKey Features\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eMultiple 2048 variants\u003c/strong\u003e in a single app\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProgression system\u003c/strong\u003e unlocking new game modes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eClean UI\u003c/strong\u003e with smooth tile animations\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eScore tracking\u003c/strong\u003e and personal bests\u003c/li\u003e\n\u003c/ul\u003e","tags":["Unity","C#","Mobile","Puzzle"],"title":"2048 Park"},{"categories":["Mobile Games"],"contents":" Overview Clay Art is an ASMR-style mobile game where players arrange colored parts onto a clay cube and enjoy the satisfying feeling of slicing through them. The game focuses on tactile, relaxing gameplay.\nPlatform: iOS / Android Engine: Unity Language: C# Genre: ASMR / Casual\nKey Features Satisfying ASMR cutting mechanics with haptic feedback Colorful clay arrangements with creative patterns Relaxing gameplay loop designed for stress relief Multiple tools and cutting styles ","date":"April 1, 2021","hero":"/images/projects/port_clayart_01.png","permalink":"http://localhost:1313/posts/mobile-clay-art/","summary":"\u003cdiv style=\"display:flex; gap:1em; flex-wrap:wrap; align-items:flex-start; margin-bottom:2em;\"\u003e\n\u003cdiv style=\"flex:1; min-width:250px;\"\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eClay Art\u003c/strong\u003e is an ASMR-style mobile game where players arrange colored parts onto a clay cube and enjoy the satisfying feeling of slicing through them. The game focuses on tactile, relaxing gameplay.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePlatform:\u003c/strong\u003e iOS / Android\n\u003cstrong\u003eEngine:\u003c/strong\u003e Unity\n\u003cstrong\u003eLanguage:\u003c/strong\u003e C#\n\u003cstrong\u003eGenre:\u003c/strong\u003e ASMR / Casual\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv style=\"flex:1; min-width:250px; max-width:400px;\"\u003e\n\u003cp\u003e\u003cimg src=\"/images/projects/port_clayart_02.png\" alt=\"Clay Art Gameplay\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003ch2 id=\"key-features\"\u003eKey Features\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSatisfying ASMR cutting mechanics\u003c/strong\u003e with haptic feedback\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eColorful clay arrangements\u003c/strong\u003e with creative patterns\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRelaxing gameplay loop\u003c/strong\u003e designed for stress relief\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMultiple tools and cutting styles\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e","tags":["Unity","C#","Mobile","ASMR"],"title":"Clay Art"},{"categories":["Mobile Games"],"contents":" Overview Climber is an in-house climbing wall simulation 3D game. Players attempt to reach the finish goal without being dropped, navigating increasingly challenging wall layouts with physics-based climbing controls.\nPlatform: Android Engine: Unity Language: C# Genre: Simulation / Casual\nView on Google Play Key Features Physics-based climbing with realistic hand/grip mechanics Procedural wall layouts with varying difficulty 3D environments with multiple climbing venues Achievement system tracking best climbs ","date":"March 1, 2021","hero":"/images/projects/port_climber_01.png","permalink":"http://localhost:1313/posts/mobile-climber/","summary":"\u003cdiv style=\"display:flex; gap:1em; flex-wrap:wrap; align-items:flex-start; margin-bottom:2em;\"\u003e\n\u003cdiv style=\"flex:1; min-width:250px;\"\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eClimber\u003c/strong\u003e is an in-house climbing wall simulation 3D game. Players attempt to reach the finish goal without being dropped, navigating increasingly challenging wall layouts with physics-based climbing controls.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePlatform:\u003c/strong\u003e Android\n\u003cstrong\u003eEngine:\u003c/strong\u003e Unity\n\u003cstrong\u003eLanguage:\u003c/strong\u003e C#\n\u003cstrong\u003eGenre:\u003c/strong\u003e Simulation / Casual\u003c/p\u003e\n\u003ca href=\"https://play.google.com/store/apps/details?id=jp.tokyosmartgames.climber\" target=\"_blank\" rel=\"noopener\"\u003e\n  View on Google Play\n\u003c/a\u003e\n\u003c/div\u003e\n\u003cdiv style=\"flex:1; min-width:250px; max-width:400px;\"\u003e\n\u003cp\u003e\u003cimg src=\"/images/projects/port_climber_02.png\" alt=\"Climber Gameplay\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003ch2 id=\"key-features\"\u003eKey Features\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePhysics-based climbing\u003c/strong\u003e with realistic hand/grip mechanics\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProcedural wall layouts\u003c/strong\u003e with varying difficulty\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e3D environments\u003c/strong\u003e with multiple climbing venues\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAchievement system\u003c/strong\u003e tracking best climbs\u003c/li\u003e\n\u003c/ul\u003e","tags":["Unity","C#","Mobile","Simulation"],"title":"Climber"},{"categories":["Mobile Games"],"contents":" Overview Assassin is a 3D puzzle game where players must eliminate enemies and save allies using limited bullets. Each level requires careful planning and strategic thinking to complete the objective.\nPlatform: iOS / Android Engine: Unity Language: C# Genre: Puzzle / Strategy\nView on App Store Key Features Limited bullet mechanic requiring strategic shot placement Enemy and ally identification — avoid friendly fire Physics-based projectiles with ricochet mechanics Escalating difficulty across dozens of levels ","date":"June 1, 2020","hero":"/images/projects/port_assasin_01.png","permalink":"http://localhost:1313/posts/mobile-assassin/","summary":"\u003cdiv style=\"display:flex; gap:1em; flex-wrap:wrap; align-items:flex-start; margin-bottom:2em;\"\u003e\n\u003cdiv style=\"flex:1; min-width:250px;\"\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eAssassin\u003c/strong\u003e is a 3D puzzle game where players must eliminate enemies and save allies using limited bullets. Each level requires careful planning and strategic thinking to complete the objective.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePlatform:\u003c/strong\u003e iOS / Android\n\u003cstrong\u003eEngine:\u003c/strong\u003e Unity\n\u003cstrong\u003eLanguage:\u003c/strong\u003e C#\n\u003cstrong\u003eGenre:\u003c/strong\u003e Puzzle / Strategy\u003c/p\u003e\n\u003ca href=\"https://apps.apple.com/app/id1501654646\" target=\"_blank\" rel=\"noopener\"\u003e\n  View on App Store\n\u003c/a\u003e\n\u003c/div\u003e\n\u003cdiv style=\"flex:1; min-width:250px; max-width:400px;\"\u003e\n\u003cp\u003e\u003cimg src=\"/images/projects/port_assasin_02.png\" alt=\"Assassin Gameplay\"\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003ch2 id=\"key-features\"\u003eKey Features\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLimited bullet mechanic\u003c/strong\u003e requiring strategic shot placement\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEnemy and ally identification\u003c/strong\u003e — avoid friendly fire\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePhysics-based projectiles\u003c/strong\u003e with ricochet mechanics\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEscalating difficulty\u003c/strong\u003e across dozens of levels\u003c/li\u003e\n\u003c/ul\u003e","tags":["Unity","C#","Mobile","Puzzle"],"title":"Assassin"}]